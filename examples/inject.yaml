esphome:
  name: ghostuart_parse_inject
  platform: ESP32
  board: esp32dev

external_components:
  - source: github://youruser/esphome_ghostuart
    components: [ ghostuart ]

# Two UARTs — adjust pins/parity/baud to your devices
uart:
  - id: uart_a
    tx_pin: GPIO17
    rx_pin: GPIO16
    baud_rate: 9600
    parity: EVEN
  - id: uart_b
    tx_pin: GPIO4
    rx_pin: GPIO2
    baud_rate: 9600
    parity: EVEN

# GhostUART: frame buffering, parsing (mappings), and injection (templates)
ghostuart:
  id: ghost
  uart_a: uart_a
  uart_b: uart_b
  max_frame: 512
  silence_ms: 0          # 0 = auto (derived from inter-byte timing)
  pre_listen_ms: 0       # 0 = auto
  debug: false           # initial; can be toggled via switch below

  # 1) Read & extract: define mappings to parse specific frame types/fields
  #    Adjust 'prefix', 'offset', 'length', 'format', and 'scale' to your protocol!
  mappings:
    - name: remote_commands
      selector:
        prefix: [0xAA, 0x02]         # example: frames coming from a remote command
      fields:
        - name: remote_setpoint
          offset: 3                  # example: 2-byte value starting at byte 3
          length: 2
          format: INT16_LE
          scale: 0.1                 # 230 → 23.0 °C
          persist: true

    - name: status_frames
      selector:
        prefix: [0xAA, 0x01]         # example: status/telemetry frames from the unit
      fields:
        - name: indoor_temp
          offset: 2
          length: 2
          format: UINT16_BE
          scale: 0.1
          persist: false

  # 2) Build & send: define templates to construct outbound frames
  #    This template appends LRC automatically and uses the stored 'remote_setpoint' variable
  #    unless it is overridden by the caller (see button below).
  templates:
    - name: setpoint_cmd
      fixed_prefix: [0xAA, 0x04, 0x02]  # header + type (EXAMPLE — adapt to your device!)
      placeholders:
        - name: remote_setpoint
          format: INT16_LE
          scale: 0.1
      append_lrc: true

# Debug toggle (shows/hides GhostUART's own ESP_LOGD messages)
switch:
  - platform: template
    id: ghost_debug
    name: "GhostUART – Debug"
    optimistic: true
    entity_category: diagnostic
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - lambda: |-
            id(ghost).set_debug(true);
    on_turn_off:
      then:
        - lambda: |-
            id(ghost).set_debug(false);

# Safety toggle for any injection (keeps passive by default)
switch:
  - platform: template
    id: ghost_inject_enable
    name: "GhostUART – Injection Enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

# Button to send a "remote_setpoint + 1.0°C" command using the template above
button:
  - platform: template
    name: "Send: Remote Setpoint +1°C"
    on_press:
      then:
        - lambda: |-
            if (!id(ghost_inject_enable).state) return;        // safety gate
            float sp = id(ghost).get_var("remote_setpoint");   // read parsed variable (scaled)
            if (isnan(sp)) return;                             // no value yet? skip
            // Override 'remote_setpoint' placeholder and send
            id(ghost).send_template("setpoint_cmd",
              { {"remote_setpoint", std::to_string(sp + 1.0f)} });

# Notes:
# - The 'prefix', 'offset', 'format', and 'scale' values are EXAMPLES. Adjust them to match your frames.
# - 'remote_setpoint' is stored when a matching frame is parsed; the button then reuses it (+1.0) to build an outbound frame.
# - With 'silence_ms: 0' and 'pre_listen_ms: 0', timing is derived automatically from the observed stream.
# - If you need verbose logs, flip the "GhostUART – Debug" switch on (no global logger level required).
